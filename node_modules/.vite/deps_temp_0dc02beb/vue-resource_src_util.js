import "./chunk-SSYGV25P.js";

// node_modules/vue-resource/src/lib/promise.js
var RESOLVED = 0;
var REJECTED = 1;
var PENDING = 2;
function Promise2(executor) {
  this.state = PENDING;
  this.value = void 0;
  this.deferred = [];
  var promise = this;
  try {
    executor(function(x) {
      promise.resolve(x);
    }, function(r) {
      promise.reject(r);
    });
  } catch (e) {
    promise.reject(e);
  }
}
Promise2.reject = function(r) {
  return new Promise2(function(resolve2, reject2) {
    reject2(r);
  });
};
Promise2.resolve = function(x) {
  return new Promise2(function(resolve2, reject2) {
    resolve2(x);
  });
};
Promise2.all = function all(iterable) {
  return new Promise2(function(resolve2, reject2) {
    var count = 0, result = [];
    if (iterable.length === 0) {
      resolve2(result);
    }
    function resolver(i2) {
      return function(x) {
        result[i2] = x;
        count += 1;
        if (count === iterable.length) {
          resolve2(result);
        }
      };
    }
    for (var i = 0; i < iterable.length; i += 1) {
      Promise2.resolve(iterable[i]).then(resolver(i), reject2);
    }
  });
};
Promise2.race = function race(iterable) {
  return new Promise2(function(resolve2, reject2) {
    for (var i = 0; i < iterable.length; i += 1) {
      Promise2.resolve(iterable[i]).then(resolve2, reject2);
    }
  });
};
var p = Promise2.prototype;
p.resolve = function resolve(x) {
  var promise = this;
  if (promise.state === PENDING) {
    if (x === promise) {
      throw new TypeError("Promise settled with itself.");
    }
    var called = false;
    try {
      var then2 = x && x["then"];
      if (x !== null && typeof x === "object" && typeof then2 === "function") {
        then2.call(x, function(x2) {
          if (!called) {
            promise.resolve(x2);
          }
          called = true;
        }, function(r) {
          if (!called) {
            promise.reject(r);
          }
          called = true;
        });
        return;
      }
    } catch (e) {
      if (!called) {
        promise.reject(e);
      }
      return;
    }
    promise.state = RESOLVED;
    promise.value = x;
    promise.notify();
  }
};
p.reject = function reject(reason) {
  var promise = this;
  if (promise.state === PENDING) {
    if (reason === promise) {
      throw new TypeError("Promise settled with itself.");
    }
    promise.state = REJECTED;
    promise.value = reason;
    promise.notify();
  }
};
p.notify = function notify() {
  var promise = this;
  nextTick(function() {
    if (promise.state !== PENDING) {
      while (promise.deferred.length) {
        var deferred = promise.deferred.shift(), onResolved = deferred[0], onRejected = deferred[1], resolve2 = deferred[2], reject2 = deferred[3];
        try {
          if (promise.state === RESOLVED) {
            if (typeof onResolved === "function") {
              resolve2(onResolved.call(void 0, promise.value));
            } else {
              resolve2(promise.value);
            }
          } else if (promise.state === REJECTED) {
            if (typeof onRejected === "function") {
              resolve2(onRejected.call(void 0, promise.value));
            } else {
              reject2(promise.value);
            }
          }
        } catch (e) {
          reject2(e);
        }
      }
    }
  });
};
p.then = function then(onResolved, onRejected) {
  var promise = this;
  return new Promise2(function(resolve2, reject2) {
    promise.deferred.push([onResolved, onRejected, resolve2, reject2]);
    promise.notify();
  });
};
p.catch = function(onRejected) {
  return this.then(void 0, onRejected);
};

// node_modules/vue-resource/src/promise.js
if (typeof Promise === "undefined") {
  window.Promise = Promise2;
}
function PromiseObj(executor, context) {
  if (executor instanceof Promise) {
    this.promise = executor;
  } else {
    this.promise = new Promise(executor.bind(context));
  }
  this.context = context;
}
PromiseObj.all = function(iterable, context) {
  return new PromiseObj(Promise.all(iterable), context);
};
PromiseObj.resolve = function(value, context) {
  return new PromiseObj(Promise.resolve(value), context);
};
PromiseObj.reject = function(reason, context) {
  return new PromiseObj(Promise.reject(reason), context);
};
PromiseObj.race = function(iterable, context) {
  return new PromiseObj(Promise.race(iterable), context);
};
var p2 = PromiseObj.prototype;
p2.bind = function(context) {
  this.context = context;
  return this;
};
p2.then = function(fulfilled, rejected) {
  if (fulfilled && fulfilled.bind && this.context) {
    fulfilled = fulfilled.bind(this.context);
  }
  if (rejected && rejected.bind && this.context) {
    rejected = rejected.bind(this.context);
  }
  return new PromiseObj(this.promise.then(fulfilled, rejected), this.context);
};
p2.catch = function(rejected) {
  if (rejected && rejected.bind && this.context) {
    rejected = rejected.bind(this.context);
  }
  return new PromiseObj(this.promise.catch(rejected), this.context);
};
p2.finally = function(callback) {
  return this.then(
    function(value) {
      callback.call(this);
      return value;
    },
    function(reason) {
      callback.call(this);
      return Promise.reject(reason);
    }
  );
};

// node_modules/vue-resource/src/util.js
var { hasOwnProperty } = {};
var { slice } = [];
var debug = false;
var ntick;
var inBrowser = typeof window !== "undefined";
function util_default({ config, nextTick: nextTick2 }) {
  ntick = nextTick2;
  debug = config.debug || !config.silent;
}
function warn(msg) {
  if (typeof console !== "undefined" && debug) {
    console.warn("[VueResource warn]: " + msg);
  }
}
function error(msg) {
  if (typeof console !== "undefined") {
    console.error(msg);
  }
}
function nextTick(cb, ctx) {
  return ntick(cb, ctx);
}
function trim(str) {
  return str ? str.replace(/^\s*|\s*$/g, "") : "";
}
function trimEnd(str, chars) {
  if (str && chars === void 0) {
    return str.replace(/\s+$/, "");
  }
  if (!str || !chars) {
    return str;
  }
  return str.replace(new RegExp(`[${chars}]+$`), "");
}
function toLower(str) {
  return str ? str.toLowerCase() : "";
}
function toUpper(str) {
  return str ? str.toUpperCase() : "";
}
var isArray = Array.isArray;
function isString(val) {
  return typeof val === "string";
}
function isBoolean(val) {
  return val === true || val === false;
}
function isFunction(val) {
  return typeof val === "function";
}
function isObject(obj) {
  return obj !== null && typeof obj === "object";
}
function isPlainObject(obj) {
  return isObject(obj) && Object.getPrototypeOf(obj) == Object.prototype;
}
function isBlob(obj) {
  return typeof Blob !== "undefined" && obj instanceof Blob;
}
function isFormData(obj) {
  return typeof FormData !== "undefined" && obj instanceof FormData;
}
function when(value, fulfilled, rejected) {
  var promise = PromiseObj.resolve(value);
  if (arguments.length < 2) {
    return promise;
  }
  return promise.then(fulfilled, rejected);
}
function options(fn, obj, opts) {
  opts = opts || {};
  if (isFunction(opts)) {
    opts = opts.call(obj);
  }
  return merge(fn.bind({ $vm: obj, $options: opts }), fn, { $options: opts });
}
function each(obj, iterator) {
  var i, key;
  if (isArray(obj)) {
    for (i = 0; i < obj.length; i++) {
      iterator.call(obj[i], obj[i], i);
    }
  } else if (isObject(obj)) {
    for (key in obj) {
      if (hasOwnProperty.call(obj, key)) {
        iterator.call(obj[key], obj[key], key);
      }
    }
  }
  return obj;
}
var assign = Object.assign || _assign;
function merge(target) {
  var args = slice.call(arguments, 1);
  args.forEach((source) => {
    _merge(target, source, true);
  });
  return target;
}
function defaults(target) {
  var args = slice.call(arguments, 1);
  args.forEach((source) => {
    for (var key in source) {
      if (target[key] === void 0) {
        target[key] = source[key];
      }
    }
  });
  return target;
}
function _assign(target) {
  var args = slice.call(arguments, 1);
  args.forEach((source) => {
    _merge(target, source);
  });
  return target;
}
function _merge(target, source, deep) {
  for (var key in source) {
    if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
      if (isPlainObject(source[key]) && !isPlainObject(target[key])) {
        target[key] = {};
      }
      if (isArray(source[key]) && !isArray(target[key])) {
        target[key] = [];
      }
      _merge(target[key], source[key], deep);
    } else if (source[key] !== void 0) {
      target[key] = source[key];
    }
  }
}
export {
  assign,
  util_default as default,
  defaults,
  each,
  error,
  inBrowser,
  isArray,
  isBlob,
  isBoolean,
  isFormData,
  isFunction,
  isObject,
  isPlainObject,
  isString,
  merge,
  nextTick,
  options,
  toLower,
  toUpper,
  trim,
  trimEnd,
  warn,
  when
};
//# sourceMappingURL=vue-resource_src_util.js.map
